    不求甚解的读书和不读有何区别
                                ———— 江峰
 
第1章 MySQL架构与历史

    下载sakila数据库结构文件和数据文件：https://dev.mysql.com/doc/index-other.html
    1.2 并发控制
        1.读写锁（又称共享锁和排他锁）：都是行级锁。
            读锁是共享的，相互不阻塞。多个客户在同一时刻可以读取同一个资源,而互补干扰。读的时候不能修改数据。
            写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。在同一时刻，只有一个用户能进行写入，并防止其他用户读取正在写入的统一资源。
        2.锁粒度：尽量只锁定需要修改的部分数据，而不是所有的资源。锁定的数据量越小，则系统的并发程度越高。加锁本身也需要消耗资源。
            锁策略：就是在锁的开销和数据的安全性之间寻求平衡，这种平衡也会影响到性能。锁策略有表锁和行级锁等。
        3.表锁：是最基本的锁策略，也是开销最小的策略，它会锁定整张表，对表进行写操作（插入，删除，修改），都需要先获取写锁，并阻塞其他用户
                对该表的读写操作。只有没有写锁时，其他用户才能获取读锁，读锁之间是不会相互阻塞的。
                注意：写锁具有比读锁更高的优先级（写锁可以插入到锁队列中读锁的前面，反之读锁则不能插入到写锁的前面）。
        4.行级锁：行级锁可以最大程度的支持并发处理(同时也带来了最大的锁开销)，行级锁只在存储引擎层实现，而MySQL服务器层没有实现。服务器从完全不了解存储引擎中的锁实现。
    1.3 事务（ACID）：事务就是一组原子性的SQL查询，或者说一个独立的工作单元。事务内的语句，要不全部执行成功，要么全部执行失败。
                        一个实现了ACID的数据库，通常需要更高的性能。所以用户需要根据是否需要事务处理，来选择合适的存储引擎。
            原子性：事务是不可分割的最小的执行单元，一个事务中的所有操作要么全部执行成功，要么全部执行失败。
            一致性：数据库总是从一个一致性的状态转换到另外一个一致性的状态。
            隔离性：通常来说，一个事务所做的修改在最终提交以前，对其他事务来说是不可见的。
            持久性：一旦事务提交，则其所做的修改就会永久的被保存到数据库中。
        1.隔离级别：
            读未提交：事务中修改，即使没有提交，对其他事务也都是可见的。
            读已提交：一个事务从开始到提交之前，对其他事务是不可见的。它是一个事务，要等另一个事务提交后才能读取数据。它可能出现不可重复读。（大多数数据库的隔离级别，如SqlServer,Oracle等）
            可重复读：解决了脏读的问题，并保证了在同一个事务中中多次读取同样的记录的结果是一致的。（MySQL默认的隔离级别）
            串行化：强制事务串行执行，避免了幻读的问题。SERIALIZABLE会在读取的每一行数据上都加锁。（性能消耗很高）
        2.死锁：是指两个或多个事务对同一资源相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。
                解决办法：死锁检测和死锁超时机制
                InnoDB处理死锁的办法是：将持有最少行级排它锁的事务进行回滚。
                锁的行为和顺序是和执行引擎有关系的，死锁发生以后，只有部分或完全回滚其中一个事务，才能打破事务。
        3.事务日志：事务日志可以帮助提高使用事务的效率。使用事务日志，存储引擎在修改表数据的时候只需要修改其内存拷贝，再将该修改行为持久化到硬盘中的事务日志中，
                    而不是每次都将数据本身持久化到磁盘。事务持久以后，内存中被修改的数据在后台可以慢慢的刷会磁盘。所以修改数据需要写两次磁盘。
        4.MySQL中的事务： 
            1.自动提交：MySQL默认采用自动提交（AUTOCOMMIT）模式，也就是说，如果不是显式的开启一个事务，则每个sql语句都被当做一个事务执行提交动作。
                        当set autocommit = 0时，所有的sql语句都是在一个事务当中，直到执行commit或rollback。该事务结束，同时又开启了另一个事务。
            2.在事务中混合使用存储引擎：MySQL服务器层是不管理事务的，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。
            3.隐式和显式锁定：InnoDB采用的是两阶段锁定协议。  
                            select ... lock in share mode; 加共享锁
                            select ... for update; 加排它锁
    1.4 多版本并发控制（MVCC）
    1.5 MySQL中的存储引擎:show table status查看表的状态信息;
        1.InnoDB存储引擎：InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。
                        InnoDB表是基于聚族索引建立的，聚族索引对主键查询有很高的性能。
        2.MyISAM存储引擎:不支持事务，不支持行级锁，且崩溃后无法安全恢复
            MyISAM特性：
                加锁与并发：MyISAM对整张表加锁，而不是针对行。读取时对对需要读取的所有表加共享锁，写入时则对表加排它锁。
                           并在读取的时候也支持插入（称为并发插入）
                修复：MySQL可以手工或者自动执行检查和修复操作，执行表的修复可能会导致部分数据丢失，并且修复操作是非常慢的。
                索引特性：对于MyISAM表，即使是BLOB和TEXT等长字段，也可以基于前500个字符创建索引，MyISAM也支持全文索引，支持复杂查询。
                延迟更新索引键：如果开启了DELY_KEY_WRITE选项，在每次修改的时候，不会立即将修改的索引数据更新到磁盘，而是会写到内存中的键缓冲区。
                            清理缓冲区或关闭表的时候才会写入到磁盘，提高了写入的性能。
                MyISAM压缩表：支持索引，压缩表不能修改（除非先解压缩，在修改，再压缩）。可以减少磁盘IO,提升查询性能。
                MyISAM性能：最典型的性能问题是表锁的问题，如果发现所有的查询都长期处于 “locked” 的状态，那么毫无疑问表锁就是罪魁祸首。 
        3.MySQL内建的其他存储引擎
        4.第三方存储引擎
        5.选择合适的存储引擎：除非用到某些InnoDB不具备的特性，并且没有其他办法替代，否则都应该优先考虑使用InnoDB引擎。
                事务：如果需要事务，选择InnoDB，不需要事务，并且主要是INSERT 和 SELECT操作，那么MyISAM是不错的选择。
                备份：如果可以定期的关闭服务器进行备份，那么备份的因素可以忽略。反之，如果需要热备份，那么选择InnoDB引擎。
                崩溃恢复：MyISAM崩溃恢复后发生损坏的概率比InnoDB高的多，而且恢复速度也很慢，所以即时不需要支持事务，很多人也选择InnoDB，这是一个很重要的因素。
            日志型应用：对插入速度有很高的要求，可以考虑使用MyISAM，开销低，插入快。
            只读或者大部分情况下只读的表：读多写少的业务，如果不介意MyISAM的崩溃恢复，选用MyISAM是合适的。
                                        不要低估崩溃后恢复问题的重要性（MySIAM引擎是只将数据写到内存中，然后操作系统定期将数据刷到磁盘中）。
            订单处理：涉及到订单处理，那么支持事务就是必须选项。InnoDB是支持订单处理的最佳选择。
            电子公告牌和主题讨论论坛：如select count(*) from table;对MyISAM是比较快的，但对于其他的存储引擎可能都不行。
            大数据量：几个TB的数据量，需要合理的选择硬件，做好物理涉及，并未服务器的I/O瓶颈做好规划。
                    在这样的数据量下，如果选用MyISAM，如果崩溃了，那么进行数据恢复基本就是凉凉。
        6.转换表的存储引擎：
            1.ALTER TABLE：比如将myTable表的存储引擎换成InnoDB,
                        CREATE TABLE innodb_table like myTable;
                        ALTER TABLE innodb_table ENGINE = INNODB;
                        INSERT INTO innodb_table SELECT * FROM myTable;
                        该操作是按行将数据从这张表复制到另一张表中，需要执行很长的时间，在复制期间可能会消耗系统所有的I/O能力，
                        同时会在原表加上读锁。所以在繁忙的表上执行此操作需要小心。   
            2.导出与导入：使用mysqldump工具将数据导出到文件等操作。
            3.创建与查询(CREATE 和 SELECT)：创建一个新的存储引擎的表，然后将数据导入到新表。数据量大的话就需要分批处理。
                                            这样操作以后，新表就是原表的一个复制。如果有必要，可以在执行的过程中对原表加锁。
    1.8 总结：MySQL拥有分层的架构。上层是服务器层的服务和查询执行引擎，下层则是执行引擎。等等。。。（对于InnoDB来说，所有的提交都是事务）

第2章 MySQL基准测试

    2.1 为什么要有基准测试：对系统的性能做出一个大概的评估， TPS(每秒事务数)
    2.2 基准测试的策略：主要有两种，一种是对整个系统进行测试（集成式基准测试），二是单独测试MySQL(单组件式基准测试)。
        1.测试何种指标：
            1.吞吐量：指的是单位时间内的事务处理数。
            2.响应时间或延迟：这个指标用于测试任务所需的整体时间。计算出平均响应时间、最小响应时间、最大响应时间和所占百分比等。
            3.并发性：Web服务器的并发性也不等同于数据库的并发性，而仅仅表示回话存储机制能够处理多少数据的能力。
                      Web服务器的并发性更正确的度量指标，应该是在任意时间有多少同时发生的并发请求。Web服务器的高并发，一般也会导致数据库的高并发。
            4.可拓展性：
            归根结底，应该测试那些对用户来说最重要的指标。
     2.3 基准测试方法：
                测试中一些常见的错误，见书82页
            
第3章 服务器性能分析

    3.1 性能优化简介：性能即响应时间。数据库服务器的目的是执行SQL语句，所以它关注的应该是查询或者语句，如SELECT,UPDATE ,DELETE等。
                        数据库的性能用查询的响应时间来度量，单位是每个查询花费的时间。
        1.通过性能剖析进行优化：
            两种类型的性能剖析：基于时间的分析和基于等待的分析。
        2.理解性能剖析：
    3.2 对应用程序进行进行性能剖析：
    3.3 剖析MySQL查询：
        1.剖析服务器负载
        2.剖析单条查询：
            set profiling = 1; 打开测量服务器中运行的所有的语句的运行时间，默认关闭。
            show profiles; 显示SQL语句的运行时间。（会发现每条语句都会创建一个id）
            show profile for query [id]; 详细显示这条语句（id）的运行时间。
            
            show status本身也会创建一条临时表
        3.使用性能剖析
    3.4 诊断间歇性问题：比如系统偶尔停顿或者慢查询。
        1.使用 SHOW GLOBAL STATUS
        
第4章 Schema与数据类型优化（4,5,6三章要多看）
    
    4.1 选择优化的数据类型
            1.更小的通常更好：一般情况下，应该选择正确存储数据的最小数据类型。（占用更少的磁盘、内存、CPU缓存）
            2.简单就好：简单数据类型的操作通常需要更少的CPU周期,整形比字符型操作代价更低（因为字符集和校对规则使字符比较比整型比较要复杂）
                    例子1：应该使用MySQL内建的类型(timeStrmp,dateTime)，而不是字符串来存储日期和时间。
                    例子2：应该使用整型来存储IP地址。
            3.尽量避免NULL：因为可为NULL的列使得索引，索引统计，和值都比较复杂。导致更难优化，把可为NULL的列改为非NULL能带来性能上的提升。
            
            在为列选择数据类型时：第一步，选择合适的大类型。数字、字符串、时间等。
                                 第二步，选择具体类型。很多MySQL的数据类型可以存储相同的数据，只是存储的范围，精度或占用磁盘和内存空间不同。
        1.整型类型：TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT。分别占用8位、16、24、32、64位存储空间。
                    整数类型有可选的UNSIGNED属性，表示不允许负数。这大致可以使整数的上限大概提升一倍。
                  
                    有符号类型与无符号类型占用相同的存储空间，并具有相同的性能，因此根据实际情况选择合适的数据类型。
                    
                    MySQL可以为整数类型指定宽度：例如int(11),对大多数应用来说，是没有意义的：它不会限制值得合法范围，只是规定
                                                了MySQL的一些（例如MySQ命令行客户端）用来显示字符的个数。对于存储和计算来说，INT(1)和INT(20)来说是一样的。
        2.实数类型：实数是带有小数部分的数字。FLOAT,DOUBLE是浮点类型，DECIMAL类型（需要额外的空间和计算开销，要慎用）。  
        3.字符串类型：
            VARCHAR：存储可变长字符串，是最常见的字符串类型。它比定长类型更节省空间，因为它使用必要的空间（例如，越短的字符串使用越少的空间）。
                    VARCHAR需要1或2个额外字节记录字符串的长度
            CHAR：定长的，MySQL根据定义的字符串长度分配足够的空间。
                    CHAR适合存储很短的字符串或者所有值都接近同一个长度。
                    
                    通常情况下使用varchar(20)和varchar(255)保持'hello'占用的空间都是一样的，但使用长度较短的列却有巨大的优势。
                    较大的列使用更多的内存，因为MySQL通常会分配固定大小的内存块来保存值，这对排序或使用基于内存的临时表尤其不好。
                    同样的事情也会发生在使用文件排序或者基于磁盘的临时表的时候。
            BLOB和TEXT类型：都是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。
                            如果查询使用了BLOB或TEXT列并且需要使用隐士临时表，将会使用磁盘临时表。这会导致严重的性能开销。    
            使用枚举（ENUM）代替字符串类型：
        4.日期和时间类型
            DATETIME:精度为秒，默认情况下，MySQL以一种可排序的，无歧义的格式显示DATETIME值，与时区无关，使用8个字节的存储空间。例如：" 2018-11-14 10:49:00 "。
            TIMESTAMP：占4个字节的存储空间， 通常情况下，应该尽量使用TIMESTAMP而不是DATETIME，因为它比DATETIME占用空间更小。
        5.位数据类型：从技术来说都是字符串类型。
            1.BIT：最好不要使用
            2.SET：缺点是改变列的代价太高。
            3.在整数列上进行按位操作：
        6.选择标识符：     
            数据库中schema指的是数据库的组织和结构。如ORM自动生成的schema可能不会存储任意的数据类型，所以要检查清楚。避免性能问题。
        7.特殊类型数据：某些数据的类型并不直接与内置类型一致。
    4.2 MySQL schema 设计中的陷阱
            太多的列：API进行工作时，会在服务器层和存储引擎层之间进行行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。字段太多的话，转换代价就会很高。
            太多的关联：一个粗略的经验法则，如果希望查询执行的快速且并发性好，单个查询最好在12个表以内做关联。但阿里巴巴开发手册，严禁超过三张表以上做关联。    
             
    4.3 范式和反范式 
        1.范式的优点很多，缺点是通常需要关联，这不但代价昂贵，且有可能使一些索引策略失效。
        2.反范式的schema因为所有的数据都在一张表里面，可以很好的避免关联。
    4.4 缓存表和汇总表
    4.5 加快ALTER TABLE操作的速度
        ALTER TABLE操作对于大表性能上是个问题。因为ALTER TABLE 是用新的结构创建一个新表，从旧表汇总查出所有数据插入到新表中，然后删除旧表。
  
第5章 创建高性能上的索引（很重要，得再看一遍）
            
         索引是存储引擎快速找到记录的一种数据结构，在MySQL中，首先在索引中找到对应值，然后在根据匹配到的索引记录找到对应的数据行。
     5.1 索引的类型
        1.B-Tree索引
            可以使用B-Tree索引查询的类型：
                全值匹配
                匹配最左前缀
                匹配列前缀
                匹配范围值
                精确匹配某一列并范围匹配另外一列
            B-Tree索引的限制
                1.如果不是按照索引的最左列开始查找，则无法使用索引。
                2.不能跳过索引中的列
                3.如果查询中有某个列的范围查询，则其右边所有的列都无法使用索引优化查询。
               
               根据索引查询时只能从第一个索引列开始依次次往后开始查询，所以建立索引是索引的列的顺序是非常重要的。
        2.哈希索引
            基于哈希表实现，只有精确匹配索引所有列的查询才有效。
            对于每一行数据，存储引擎都会对所有的索引列计算一个哈希吗，哈希吗是一个较小的值，并且不同键值的行计算出来的哈希吗是不一样的。
            哈希索引将所有的哈希吗存储在索引中，同时在哈希表中保存指向每个数据行的指针。
            
            因为索引只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。
          
          哈希索引的限制很多，比如只能进行等值比较查询。
        3.空间数据索引
        4.全文索引：是一种特殊类型的索引，它查找的是文本中的关键字词，而不是直接比较索引中的值。
                    全文索引更类似于搜索引擎做的事情，而不是简单的WHERE条件匹配。
     5.2 索引的优点
            索引可以让服务器快速定位到表的指定位置。B-Tree索引是按照顺序存储数据。               
            索引总结下来有如下三个优点：
            1.索引大大减少服务器需要扫描的数据量
            2.索引可以帮助服务器避免排序和临时表
            3.索引可以将随机I/O变成顺序I/O
     5.3 高性能的索引策略
        1.独立的列：独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。始终将索引列放在符号的一侧。
        2.前缀索引和索引选择性:
        3.多列索引
        4.选择合适的索引列顺序
        5.聚簇索引：InnodDB通过主键聚集数据。
                    顺序的主键并不一定都是好的，对于高并发工作负载，在InnoDB中按主键顺序插入可能会造成明显的争用。
                     1.主键上界成为“热点”，因为所有的插入都发生在这里，并发插入可能造成间隙锁竞争。
                     2.AUTO_increment锁机制，遇到这个问题考虑重新设计表或者应用，或者更改innodb_autoinc_lock_mode配置。                          
        6.覆盖索引：索引中包含所有需要查询的字段的值，也就是说可以通过索引直接获取列的数据，不需要再读取数据行。
                    能够极大的提高性能。查询只需要扫描索引而无需回表。            
        7.使用索引扫描来做排序
        8.压缩（前缀压缩）索引
        9.冗余和重复索引：MySQL的唯一限制和主键限制都是通过索引来实现的。
                         如果创建了索引（A,B），再创建索引（A）就是冗余索引，因为这只是前一个索引的前缀索引。
                         冗余索引通常发生在为表添加新索引的时候。
        10.未使用的索引：建议删除。使用Percona Server或Percona Toolkit中的pt-index-usage进行定位未使用的索引。
        11.索引和锁：
     5.4 索引案例学习
        1.支持多种过滤条件
        2.避免多个范围条件：
            in 和 where 的查询类型type都是“range”类型，但其实in的查询就是多个等值查询。对于范围条件查询，MySQL无法再使用范围列后面的索引列了，
            但是对于“多个等值条件查询”则没有这个限制。
        3.优化排序：比如查询分页时比较靠后的数据，有一个比较好的策略就是延迟关联，通过使用覆盖索引查询需要返回的主键，在根据这些主键关联原表
     5.5 维护索引和表
            维护表有三个主要的目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。
        1.找到并修复损坏的表：对于MyISAM存储引擎，表损坏通常是系统崩溃造成的。
            使用CHECK TABLE <表名> 来检查表是否损坏，使用REPAIR TABLE <表名>
        2.更新索引统计信息：可以使用ANALYZE TABLE命令获取统计信息
        3.减少索引和数据的碎片
            B-Tree索引可能会碎片化，这会降低查询的效率。
            表的数据也可能会碎片化，有三种类型的数据碎片：
                行碎片：
                行间碎片
                剩余空间碎片
             可以通过OPTIMIZE TABLE或者导入再导出的方式来重新整理数据。
     5.6 总结：在选择索引和编写利用这些索引的查询时，有如下三个原则始终需要记住：
                1.单行访问时很慢的。
                2.按顺序访问数据时很快的。
                3.索引覆盖查询时很快的。如果一个索引包含了查询中的所有列，那么存储引擎就不需要再回表查询。这就避免了大量的单行访问，单行访问时很慢的。        

第6章 查询性能优化

        库表结构优化，索引优化，查询优化才能实现高性能。减少查询的响应时间。
     6.1 为什么查询会慢：查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后咋服务器上进行解析，生成执行计划，执行，并返回结果给客户端。
                        其中“执行”被认为是最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序，分组等。
     6.2 慢查询基础：优化数据访问
            查询性能最基本的原因就是向数据库放为的数据太多。
            对于低效的查询，通过以下两个步骤来分析总是很有效。
                1.确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，当有时候也有可能是访问了太多的列。
                2.确认MySQL服务器层是否放在分析大量超过需要的数据行。
        1.是否想数据库请求了不需要的数据：
            请求了不需要的数据的话会给MySQL带来额外的负担，并增加网络开销，另外也会消耗应用服务器的CPU和内存资源。
            典型案例：查询不需要的记录  
                     多表关联时返回全部列
                     总是取出全部列：最好不要使用SELECT * 。。。
                     重复查询相同的数据：第一次查询的建议缓存起来，以后查询就直接从缓存中读取。
        2.MySQL是否在扫描额外的记录
            在确定查询值返回需要的数据以后， 接下来应该看看查询为了返回结果是否 扫描了过多的数据。
                衡量查询开销的三个指标：
                    1.响应时间
                    2.查询的行数
                    3.返回的行数
                这三个指标都会记录到MySQL的满日志中
            1.响应时间：
                响应时间是两个部分之和：服务时间和排队时间。
                服务时间是指数据库处理这个查询真正花了多少时间。排队时间是指服务器因为等待某些资源而没有真正执行查询的时间——可能是等I/O操作完成，也可能是等待行锁等等。
            2.扫描的行数和返回的行数
            3.扫描的行数和访问类型
                EXPLAIN语句中的type列表示访问类型。访问类型有全盘扫描，索引扫描，范围扫描，唯一索引扫描，常数引用等。
                type -- 连接类型。这里只记录和理解最重要且经常遇见的六种类型，它们分别是all,index,range,ref,ref_eq，const。从左到右，它们的效率依次是增强的。
                    all：全表扫描
                    index：这种连接类型只是另外一种形式的全表扫描，只不过它的扫描顺序是按照索引的顺序，然后根据索引回表取数据。
                    range：range指的是有范围的索引扫描，相对于index的全索引扫描，它有范围限制，因此要优于index。关于range比较容易理解，
                            需要记住的是出现了range，则一定是基于索引的。同时除了显而易见的between，and以及'>','<'外，in和or也是索引范围扫描。
                    ref：查找条件列使用了索引而且不为主键和unique。其实，意思就是虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，
                         仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。
                    ref_eq：使用了主键或者唯一性索引进行查找，这种连接类型每次都进行着精确查询，无需过多的扫描，因此查找效率更高，当然列的唯一性是需要根据实际情况决定的。
                    const：通常情况下，如果将一个主键放置到where后面作为条件查询，mysql优化器就能把这次查询优化转化为一个常量。至于如何转化以及何时转化，这个取决于优化器。
                好的索引可以让查询使用合适的访问类型，尽可能的只扫描需要的行。
                理解一个查询需要扫描多少行和实际需要使用的行数需要先去理解这个查询背后的逻辑和思想。
                如果发现查询需要扫描大量的数据但只返回少量的行数，那么通常可以尝试下面的技巧去优化它。
                   1.使用索引覆盖扫描，把所有需要用到的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了。
                   2.改变库表结构。例如使用单独的汇总表。
                   3.重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询。
     6.3 重构查询的方式
        1.一个复杂查询还是多个简单查询：在其他条件都相同的时候，使用尽可能少的查询自然是更好的。但是有时候，将一个大查询分解为多个小查询是很有必要的。
        2.切分查询：对于一个大查询有时候需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只完成一小部分查询结果。
                    比如删除旧的数据，可以分多次删除。
        3.分解关联查询：可以对每一个表进行一次简单的查询，然后将结果在应用程序中进行关联。
                        用分解关联查询重构查询有如下优势：
                        1.让缓存的效率更高。
                        2.将查询分解后，执行单个查询可以减少锁的竞争。
                        3.在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和高拓展。
                        4.查询本身效率也可能会有所提升。
                        5.可以减少冗余记录的查询。
                      在很多场景下，通过重构查询将关联放到应用程序中将会更加高效，这样的场景有很多。比如：当应用能够方便的缓存单个查询结果的时候，
                            当可以将数据分布到不同的MySQL服务器的时候，当能够使用IN()的方式代替关联查询的时候，当查询中使用同一个数据表的时候。
     6.4 查询执行的基础：
            MySQL执行一个查询的过程（流程图见248页）
                1.客户端发送一条查询给服务器。
                2.服务器会先查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则，进入下一阶段。
                3.服务器进行SQL解析，预处理，再由优化器生成对应的执行计划。
                4.MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。
                5.将结果返回给客户端。
        1.MySQL客户端/服务器通信协议       
            
 


  一个人有两块手表就永远不知道时间。