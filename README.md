第一章：MySql架构与历史
    
    1.2 并发控制
        1.读写锁（又称共享锁和排他锁）：
            读锁是共享的，相互不阻塞。多个客户在同一时刻可以读取同一个资源,而互补干扰。
            写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。在同一时刻，只有一个用户能进行写入，并防止其他用户读取正在写入的统一资源。
        2.锁粒度：尽量只锁定需要修改的部分数据，而不是所有的资源。锁定的数据量越小，则系统的并发程度越高。加锁本身也需要消耗资源。
            锁策略：就是在锁的开销和数据的安全性之间寻求平衡，这种平衡也会影响到性能。锁策略有表锁和行级锁等。
        3.表锁：是最基本的锁策略，也是开销最小的策略，它会锁定整张表，对表进行写操作（插入，删除，修改），都需要先获取写锁，并阻塞其他用户
                对该表的读写操作。只有没有写锁时，其他用户才能获取读锁，读锁之间是不会相互阻塞的。
                注意：写锁具有比读锁更高的优先级（写锁可以插入到锁队列中读锁的前面，反之读锁则不能插入到写锁的前面）。
        4.行级锁：行级锁可以最大程度的支持并发处理(同时也带来了最大的锁开销)，行级锁只在存储引擎层实现，而MySQL服务器层没有实现。服务器从完全不了解存储引擎中的锁实现。
    1.3 事务（ACID）：事务就是一组原子性的SQL查询，或者说一个独立的工作单元。事务内的语句，要不全部执行成功，要么全部执行失败。
                        一个实现了ACID的数据库，通常需要更高的性能。所以用户需要根据是否需要事务处理，来选择合适的存储引擎。
            原子性：事务是不可分割的最小的执行单元，一个事务中的所有操作要么全部执行成功，要么全部执行失败。
            一致性：数据库总是从一个一致性的状态转换到另外一个一致性的状态。
            隔离性：通常来说，一个事务所做的修改在最终提交以前，对其他事务来说是不可见的。
            持久性：一旦事务提交，则其所做的修改就会永久的被保存到数据库中。
        1.隔离级别
            读未提交：事务中修改，即使没有提交，对其他事务也都是可见的。
            读已提交：一个事务从开始到提交之前，对其他事务是不可见的。
            可重复读：
            串行化
            