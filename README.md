第一章：MySql架构与历史
    
    1.2 并发控制
        1.读写锁（又称共享锁和排他锁）：都是行级锁。
            读锁是共享的，相互不阻塞。多个客户在同一时刻可以读取同一个资源,而互补干扰。读的时候不能修改数据。
            写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。在同一时刻，只有一个用户能进行写入，并防止其他用户读取正在写入的统一资源。
        2.锁粒度：尽量只锁定需要修改的部分数据，而不是所有的资源。锁定的数据量越小，则系统的并发程度越高。加锁本身也需要消耗资源。
            锁策略：就是在锁的开销和数据的安全性之间寻求平衡，这种平衡也会影响到性能。锁策略有表锁和行级锁等。
        3.表锁：是最基本的锁策略，也是开销最小的策略，它会锁定整张表，对表进行写操作（插入，删除，修改），都需要先获取写锁，并阻塞其他用户
                对该表的读写操作。只有没有写锁时，其他用户才能获取读锁，读锁之间是不会相互阻塞的。
                注意：写锁具有比读锁更高的优先级（写锁可以插入到锁队列中读锁的前面，反之读锁则不能插入到写锁的前面）。
        4.行级锁：行级锁可以最大程度的支持并发处理(同时也带来了最大的锁开销)，行级锁只在存储引擎层实现，而MySQL服务器层没有实现。服务器从完全不了解存储引擎中的锁实现。
    1.3 事务（ACID）：事务就是一组原子性的SQL查询，或者说一个独立的工作单元。事务内的语句，要不全部执行成功，要么全部执行失败。
                        一个实现了ACID的数据库，通常需要更高的性能。所以用户需要根据是否需要事务处理，来选择合适的存储引擎。
            原子性：事务是不可分割的最小的执行单元，一个事务中的所有操作要么全部执行成功，要么全部执行失败。
            一致性：数据库总是从一个一致性的状态转换到另外一个一致性的状态。
            隔离性：通常来说，一个事务所做的修改在最终提交以前，对其他事务来说是不可见的。
            持久性：一旦事务提交，则其所做的修改就会永久的被保存到数据库中。
        1.隔离级别：
            读未提交：事务中修改，即使没有提交，对其他事务也都是可见的。
            读已提交：一个事务从开始到提交之前，对其他事务是不可见的。它是一个事务，要等另一个事务提交后才能读取数据。它可能出现不可重复读。（大多数数据库的隔离级别，如SqlServer,Oracle等）
            可重复读：解决了脏读的问题，并保证了在同一个事务中中多次读取同样的记录的结果是一致的。（MySQL默认的隔离级别）
            串行化：强制事务串行执行，避免了幻读的问题。SERIALIZABLE会在读取的每一行数据上都加锁。（性能消耗很高）
        2.死锁：是指两个或多个事务对同一资源相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。
                解决办法：死锁检测和死锁超时机制
                InnoDB处理死锁的办法是：将持有最少行级排它锁的事务进行回滚。
                锁的行为和顺序是和执行引擎有关系的，死锁发生以后，只有部分或完全回滚其中一个事务，才能打破事务。
        3.事务日志：事务日志可以帮助提高使用事务的效率。使用事务日志，存储引擎在修改表数据的时候只需要修改其内存拷贝，再将该修改行为持久化到硬盘中的事务日志中，
                    而不是每次都将数据本身持久化到磁盘。事务持久以后，内存中被修改的数据在后台可以慢慢的刷会磁盘。所以修改数据需要写两次磁盘。
        4.MySQL中的事务： 
            1.自动提交：MySQL默认采用自动提交（AUTOCOMMIT）模式，也就是说，如果不是显式的开启一个事务，则每个sql语句都被当做一个事务执行提交动作。
                        当set autocommit = 0时，所有的sql语句都是在一个事务当中，直到执行commit或rollback。该事务结束，同时又开启了另一个事务。
            2.在事务中混合使用存储引擎：MySQL服务器层是不管理事务的，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。
            3.隐式和显式锁定：InnoDB采用的是两阶段锁定协议。        
    1.4 多版本并发控制（MVCC）
    1.5 MySQL中的存储引擎:show table status查看表的状态信息;
        1.InnoDB存储引擎：InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。
                        InnoDB表是基于聚族索引建立的，聚族索引对主键查询有很高的性能。
        2.MyISAM存储引擎:不支持事务，不支持行级锁，且崩溃后无法安全恢复
            MyISAM特性：
                加锁与并发：MyISAM对整张表加锁，而不是针对行。读取时对对需要读取的所有表加共享锁，写入时则对表加排它锁。
                           并在读取的时候也支持插入（称为并发插入）
                修复：MySQL可以手工或者自动执行检查和修复操作，执行表的修复可能会导致部分数据丢失，并且修复操作是非常慢的。
                索引特性：对于MyISAM表，即使是BLOB和TEXT等长字段，也可以基于前500个字符创建索引，MyISAM也支持全文索引，支持复杂查询。
                延迟更新索引键：如果开启了DELY_KEY_WRITE选项，在每次修改的时候，不会立即将修改的索引数据更新到磁盘，而是会写到内存中的键缓冲区。
                            清理缓冲区或关闭表的时候才会写入到磁盘，提高了写入的性能。
                MyISAM压缩表：支持索引，压缩表不能修改（除非先解压缩，在修改，再压缩）。可以减少磁盘IO,提升查询性能。
                   